inherit fossa_utils

FOSSA_METADATA_RECIPES ??= "${TMPDIR}/fossa_metadata/recipes"
FOSSA_METADATA_PATCHED_SRC ??= "${TMPDIR}/fossa_metadata/src"
FOSSA_STAGING_DIR ??= "${TMPDIR}/fossa_metadata/staging"

addtask do_fossa_archive after do_packagedata before do_rm_work
do_fossa_archive[doc] = "Copies patched source code to a destination for license scanning"
do_fossa_archive[nostamp] = "1"
do_fossa_archive[rdeptask] += "do_unpack"
do_fossa_archive[rdeptask] += "do_packagedata"
do_fossa_archive[rdeptask] += "do_patch"

# This task runs after the `do_patch` task.
#
# The `do_patch` task is executed for each package in the build; in this way
# `do_fossa_archive` is able to save the package information and source code 
# for every package that goes into the build.
#
# The temporary files containing this metadata are then combined into a
# `fossa-deps` file by the `do_fossa` task. The source is then scanned
# by the `do_fossa_analyze` task.
python do_fossa_archive() {
    if not is_fossa_enabled(d):
        bb.debug(1, "Since FOSSA_ENABLED is 0, skipping: archive patched source")
        return

    if not is_fossa_license_scan_enabled(d):
        bb.debug(1, "Since FOSSA_LICENSE_SCAN is 0, skipping: archive patched source")
        return

    metadata = pkg_metadata(d)
    name = metadata['name']

    # Unfortunately it is time consuming and a bit wasteful to copy the sources like this,
    # but referencing the original source isn't possible because by the time `do_fossa_analyze` runs
    # the original source dirs are gone.
    write_metadata(d, metadata)
    copy_src(d, metadata)
}

addtask do_fossa_pkg after do_packagedata before do_rm_work
do_fossa_pkg[doc] = "Stores recipe metadata for future analysis"
do_fossa_pkg[nostamp] = "1"
do_fossa_pkg[rdeptask] += "do_unpack"
do_fossa_pkg[rdeptask] += "do_packagedata"

# This task runs after the `do_packagedata` task.
#
# The `do_packagedata` task is executed for each package in the build; in this way
# `do_fossa_pkg` is able to save the package information for every package
# that goes into the build.
#
# These temporary files are then combined into a `fossa-deps` file
# by the `do_fossa` task.
python do_fossa_pkg() {
    if not is_fossa_enabled(d):
        bb.debug(1, "Since FOSSA_ENABLED is 0, skipping: creating recipe parsing")
        return

    if is_fossa_license_scan_enabled(d):
        bb.debug(1, "Since FOSSA_LICENSE_SCAN is 1, skipping: creating recipe parsing")
        return

    metadata = pkg_metadata(d)
    name = metadata['name']

    write_metadata(d, metadata)
}

# Combines all the metadata files generated by `do_fossa_pkg` into a single
# `fossa-deps` file for use during `fossa_upload:do_fossa_analyze`.
#
# This task is run as a "post processing" step for `do_rootfs`.
# See the Yocto image generation diagram for more information: https://docs.yoctoproject.org/overview-manual/concepts.html#image-generation
#
# The idea is that after all the dependencies have been built and put in place,
# the `do_rootfs` post processing commands are run.
#
# `do_fossa` is placed as the last post processing command so that it
# is able to run at the last possible moment prior to actually building the image,
# this way it is able to capture the output of `do_fossa_pkg` for every
# package that was processed.
python do_fossa() {
    from oe.rootfs import image_list_installed_packages

    if not is_fossa_enabled(d):
        bb.debug(1, "Since FOSSA_ENABLED is 0, skipping: creating fossa-deps.json")
        return 

    import errno
    import os
    import json
    import glob
    
    metadata_dir = d.getVar('FOSSA_METADATA_RECIPES')
    pkg_metadata = all_pkg_metadata(d, metadata_dir)
    pkgs = image_list_installed_packages(d)

    installed_pkgs = []
    for pkg in pkgs:
        try:
            installed_pkgs.append(mk_user_dependencies(pkg_metadata[pkg]))
        except Exception:
            pass

    # Ensure path exists
    fossa_deps_dir = d.getVar("FOSSA_STAGING_DIR")
    bb.utils.mkdirhier(fossa_deps_dir)
    fossa_deps_path = os.path.join(fossa_deps_dir, 'fossa-deps.json')
    fossa_deps_raw = os.path.join(fossa_deps_dir, 'fossa-raw.json')

    # Make fossa-deps.json from installed pakckages,
    # provided initial deps file (if any), while excluding
    # deps provided in exclusion list.
    fossa_deps_dict = mk_fossa_deps(d, installed_pkgs, pkg_metadata)

    with open(fossa_deps_path, 'w+') as fd:
        json.dump(fossa_deps_dict, fd, indent=4, sort_keys=False)
    
    with open(fossa_deps_raw, 'w+') as fr:
        json.dump(pkg_metadata, fr, indent=4, sort_keys=False)
    
    bb.debug(1, "Wrote fossa-deps at: {fossa_deps_path}")
}

# Users only add this class to their build; implicitly add the `fossa_upload` class as well.
IMAGE_CLASSES_append = " fossa_upload"

ROOTFS_POSTPROCESS_COMMAND += " do_fossa;"

do_rootfs[recrdeptask] += "do_fossa_pkg"
do_rootfs[recrdeptask] += "do_fossa_archive"

do_rootfs[recideptask] += "do_fossa_pkg"
do_rootfs[recideptask] += "do_fossa_archive"
